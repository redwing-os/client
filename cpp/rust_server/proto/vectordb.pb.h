// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rust_server/proto/vectordb.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_rust_5fserver_2fproto_2fvectordb_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_rust_5fserver_2fproto_2fvectordb_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_rust_5fserver_2fproto_2fvectordb_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_rust_5fserver_2fproto_2fvectordb_2eproto;
namespace vectordb {
class VectorBatchWriteRequest;
struct VectorBatchWriteRequestDefaultTypeInternal;
extern VectorBatchWriteRequestDefaultTypeInternal _VectorBatchWriteRequest_default_instance_;
class VectorDeleteRequest;
struct VectorDeleteRequestDefaultTypeInternal;
extern VectorDeleteRequestDefaultTypeInternal _VectorDeleteRequest_default_instance_;
class VectorDeleteResponse;
struct VectorDeleteResponseDefaultTypeInternal;
extern VectorDeleteResponseDefaultTypeInternal _VectorDeleteResponse_default_instance_;
class VectorEmbedAndWriteRequest;
struct VectorEmbedAndWriteRequestDefaultTypeInternal;
extern VectorEmbedAndWriteRequestDefaultTypeInternal _VectorEmbedAndWriteRequest_default_instance_;
class VectorReadRequest;
struct VectorReadRequestDefaultTypeInternal;
extern VectorReadRequestDefaultTypeInternal _VectorReadRequest_default_instance_;
class VectorReadResponse;
struct VectorReadResponseDefaultTypeInternal;
extern VectorReadResponseDefaultTypeInternal _VectorReadResponse_default_instance_;
class VectorUpdateRequest;
struct VectorUpdateRequestDefaultTypeInternal;
extern VectorUpdateRequestDefaultTypeInternal _VectorUpdateRequest_default_instance_;
class VectorUpdateResponse;
struct VectorUpdateResponseDefaultTypeInternal;
extern VectorUpdateResponseDefaultTypeInternal _VectorUpdateResponse_default_instance_;
class VectorWriteRequest;
struct VectorWriteRequestDefaultTypeInternal;
extern VectorWriteRequestDefaultTypeInternal _VectorWriteRequest_default_instance_;
class VectorWriteResponse;
struct VectorWriteResponseDefaultTypeInternal;
extern VectorWriteResponseDefaultTypeInternal _VectorWriteResponse_default_instance_;
}  // namespace vectordb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace vectordb {

// ===================================================================


// -------------------------------------------------------------------

class VectorWriteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorWriteResponse) */ {
 public:
  inline VectorWriteResponse() : VectorWriteResponse(nullptr) {}
  ~VectorWriteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorWriteResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorWriteResponse(const VectorWriteResponse& from)
      : VectorWriteResponse(nullptr, from) {}
  VectorWriteResponse(VectorWriteResponse&& from) noexcept
    : VectorWriteResponse() {
    *this = ::std::move(from);
  }

  inline VectorWriteResponse& operator=(const VectorWriteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorWriteResponse& operator=(VectorWriteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorWriteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorWriteResponse* internal_default_instance() {
    return reinterpret_cast<const VectorWriteResponse*>(
               &_VectorWriteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VectorWriteResponse& a, VectorWriteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorWriteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorWriteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorWriteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorWriteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorWriteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorWriteResponse& from) {
    VectorWriteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorWriteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorWriteResponse";
  }
  protected:
  explicit VectorWriteResponse(::google::protobuf::Arena* arena);
  VectorWriteResponse(::google::protobuf::Arena* arena, const VectorWriteResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorWriteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorWriteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorWriteRequest) */ {
 public:
  inline VectorWriteRequest() : VectorWriteRequest(nullptr) {}
  ~VectorWriteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorWriteRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorWriteRequest(const VectorWriteRequest& from)
      : VectorWriteRequest(nullptr, from) {}
  VectorWriteRequest(VectorWriteRequest&& from) noexcept
    : VectorWriteRequest() {
    *this = ::std::move(from);
  }

  inline VectorWriteRequest& operator=(const VectorWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorWriteRequest& operator=(VectorWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorWriteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorWriteRequest*>(
               &_VectorWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VectorWriteRequest& a, VectorWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorWriteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorWriteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorWriteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorWriteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorWriteRequest& from) {
    VectorWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorWriteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorWriteRequest";
  }
  protected:
  explicit VectorWriteRequest(::google::protobuf::Arena* arena);
  VectorWriteRequest(::google::protobuf::Arena* arena, const VectorWriteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // repeated float vector = 2;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vector();

  public:
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorWriteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> vector_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorUpdateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorUpdateResponse) */ {
 public:
  inline VectorUpdateResponse() : VectorUpdateResponse(nullptr) {}
  ~VectorUpdateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorUpdateResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorUpdateResponse(const VectorUpdateResponse& from)
      : VectorUpdateResponse(nullptr, from) {}
  VectorUpdateResponse(VectorUpdateResponse&& from) noexcept
    : VectorUpdateResponse() {
    *this = ::std::move(from);
  }

  inline VectorUpdateResponse& operator=(const VectorUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorUpdateResponse& operator=(VectorUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const VectorUpdateResponse*>(
               &_VectorUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VectorUpdateResponse& a, VectorUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorUpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorUpdateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorUpdateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorUpdateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorUpdateResponse& from) {
    VectorUpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorUpdateResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorUpdateResponse";
  }
  protected:
  explicit VectorUpdateResponse(::google::protobuf::Arena* arena);
  VectorUpdateResponse(::google::protobuf::Arena* arena, const VectorUpdateResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorUpdateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorUpdateRequest) */ {
 public:
  inline VectorUpdateRequest() : VectorUpdateRequest(nullptr) {}
  ~VectorUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorUpdateRequest(const VectorUpdateRequest& from)
      : VectorUpdateRequest(nullptr, from) {}
  VectorUpdateRequest(VectorUpdateRequest&& from) noexcept
    : VectorUpdateRequest() {
    *this = ::std::move(from);
  }

  inline VectorUpdateRequest& operator=(const VectorUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorUpdateRequest& operator=(VectorUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const VectorUpdateRequest*>(
               &_VectorUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VectorUpdateRequest& a, VectorUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorUpdateRequest& from) {
    VectorUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorUpdateRequest";
  }
  protected:
  explicit VectorUpdateRequest(::google::protobuf::Arena* arena);
  VectorUpdateRequest(::google::protobuf::Arena* arena, const VectorUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // repeated float vector = 2;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vector();

  public:
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> vector_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorReadResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorReadResponse) */ {
 public:
  inline VectorReadResponse() : VectorReadResponse(nullptr) {}
  ~VectorReadResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorReadResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorReadResponse(const VectorReadResponse& from)
      : VectorReadResponse(nullptr, from) {}
  VectorReadResponse(VectorReadResponse&& from) noexcept
    : VectorReadResponse() {
    *this = ::std::move(from);
  }

  inline VectorReadResponse& operator=(const VectorReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorReadResponse& operator=(VectorReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorReadResponse* internal_default_instance() {
    return reinterpret_cast<const VectorReadResponse*>(
               &_VectorReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VectorReadResponse& a, VectorReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorReadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorReadResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorReadResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorReadResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorReadResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorReadResponse& from) {
    VectorReadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorReadResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorReadResponse";
  }
  protected:
  explicit VectorReadResponse(::google::protobuf::Arena* arena);
  VectorReadResponse(::google::protobuf::Arena* arena, const VectorReadResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 1,
    kFoundFieldNumber = 2,
  };
  // repeated float vector = 1;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vector();

  public:
  // bool found = 2;
  void clear_found() ;
  bool found() const;
  void set_found(bool value);

  private:
  bool _internal_found() const;
  void _internal_set_found(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorReadResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> vector_;
    bool found_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorReadRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorReadRequest) */ {
 public:
  inline VectorReadRequest() : VectorReadRequest(nullptr) {}
  ~VectorReadRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorReadRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorReadRequest(const VectorReadRequest& from)
      : VectorReadRequest(nullptr, from) {}
  VectorReadRequest(VectorReadRequest&& from) noexcept
    : VectorReadRequest() {
    *this = ::std::move(from);
  }

  inline VectorReadRequest& operator=(const VectorReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorReadRequest& operator=(VectorReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorReadRequest* internal_default_instance() {
    return reinterpret_cast<const VectorReadRequest*>(
               &_VectorReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VectorReadRequest& a, VectorReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorReadRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorReadRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorReadRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorReadRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorReadRequest& from) {
    VectorReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorReadRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorReadRequest";
  }
  protected:
  explicit VectorReadRequest(::google::protobuf::Arena* arena);
  VectorReadRequest(::google::protobuf::Arena* arena, const VectorReadRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorReadRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorEmbedAndWriteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorEmbedAndWriteRequest) */ {
 public:
  inline VectorEmbedAndWriteRequest() : VectorEmbedAndWriteRequest(nullptr) {}
  ~VectorEmbedAndWriteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorEmbedAndWriteRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorEmbedAndWriteRequest(const VectorEmbedAndWriteRequest& from)
      : VectorEmbedAndWriteRequest(nullptr, from) {}
  VectorEmbedAndWriteRequest(VectorEmbedAndWriteRequest&& from) noexcept
    : VectorEmbedAndWriteRequest() {
    *this = ::std::move(from);
  }

  inline VectorEmbedAndWriteRequest& operator=(const VectorEmbedAndWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorEmbedAndWriteRequest& operator=(VectorEmbedAndWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorEmbedAndWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorEmbedAndWriteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorEmbedAndWriteRequest*>(
               &_VectorEmbedAndWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VectorEmbedAndWriteRequest& a, VectorEmbedAndWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorEmbedAndWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorEmbedAndWriteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorEmbedAndWriteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorEmbedAndWriteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorEmbedAndWriteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorEmbedAndWriteRequest& from) {
    VectorEmbedAndWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorEmbedAndWriteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorEmbedAndWriteRequest";
  }
  protected:
  explicit VectorEmbedAndWriteRequest(::google::protobuf::Arena* arena);
  VectorEmbedAndWriteRequest(::google::protobuf::Arena* arena, const VectorEmbedAndWriteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKeyFieldNumber = 1,
    kRowsFieldNumber = 3,
    kColsFieldNumber = 4,
  };
  // repeated float data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField<float>& data() const;
  ::google::protobuf::RepeatedField<float>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_data() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_data();

  public:
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // int32 rows = 3;
  void clear_rows() ;
  ::int32_t rows() const;
  void set_rows(::int32_t value);

  private:
  ::int32_t _internal_rows() const;
  void _internal_set_rows(::int32_t value);

  public:
  // int32 cols = 4;
  void clear_cols() ;
  ::int32_t cols() const;
  void set_cols(::int32_t value);

  private:
  ::int32_t _internal_cols() const;
  void _internal_set_cols(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorEmbedAndWriteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> data_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::int32_t rows_;
    ::int32_t cols_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorDeleteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorDeleteResponse) */ {
 public:
  inline VectorDeleteResponse() : VectorDeleteResponse(nullptr) {}
  ~VectorDeleteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorDeleteResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorDeleteResponse(const VectorDeleteResponse& from)
      : VectorDeleteResponse(nullptr, from) {}
  VectorDeleteResponse(VectorDeleteResponse&& from) noexcept
    : VectorDeleteResponse() {
    *this = ::std::move(from);
  }

  inline VectorDeleteResponse& operator=(const VectorDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorDeleteResponse& operator=(VectorDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const VectorDeleteResponse*>(
               &_VectorDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VectorDeleteResponse& a, VectorDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorDeleteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorDeleteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorDeleteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorDeleteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorDeleteResponse& from) {
    VectorDeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorDeleteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorDeleteResponse";
  }
  protected:
  explicit VectorDeleteResponse(::google::protobuf::Arena* arena);
  VectorDeleteResponse(::google::protobuf::Arena* arena, const VectorDeleteResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorDeleteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorDeleteRequest) */ {
 public:
  inline VectorDeleteRequest() : VectorDeleteRequest(nullptr) {}
  ~VectorDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorDeleteRequest(const VectorDeleteRequest& from)
      : VectorDeleteRequest(nullptr, from) {}
  VectorDeleteRequest(VectorDeleteRequest&& from) noexcept
    : VectorDeleteRequest() {
    *this = ::std::move(from);
  }

  inline VectorDeleteRequest& operator=(const VectorDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorDeleteRequest& operator=(VectorDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorDeleteRequest*>(
               &_VectorDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VectorDeleteRequest& a, VectorDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorDeleteRequest& from) {
    VectorDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorDeleteRequest";
  }
  protected:
  explicit VectorDeleteRequest(::google::protobuf::Arena* arena);
  VectorDeleteRequest(::google::protobuf::Arena* arena, const VectorDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorBatchWriteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorBatchWriteRequest) */ {
 public:
  inline VectorBatchWriteRequest() : VectorBatchWriteRequest(nullptr) {}
  ~VectorBatchWriteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorBatchWriteRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorBatchWriteRequest(const VectorBatchWriteRequest& from)
      : VectorBatchWriteRequest(nullptr, from) {}
  VectorBatchWriteRequest(VectorBatchWriteRequest&& from) noexcept
    : VectorBatchWriteRequest() {
    *this = ::std::move(from);
  }

  inline VectorBatchWriteRequest& operator=(const VectorBatchWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorBatchWriteRequest& operator=(VectorBatchWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorBatchWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorBatchWriteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorBatchWriteRequest*>(
               &_VectorBatchWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VectorBatchWriteRequest& a, VectorBatchWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorBatchWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorBatchWriteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorBatchWriteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorBatchWriteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorBatchWriteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorBatchWriteRequest& from) {
    VectorBatchWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorBatchWriteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorBatchWriteRequest";
  }
  protected:
  explicit VectorBatchWriteRequest(::google::protobuf::Arena* arena);
  VectorBatchWriteRequest(::google::protobuf::Arena* arena, const VectorBatchWriteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorsFieldNumber = 1,
  };
  // repeated .vectordb.VectorWriteRequest vectors = 1;
  int vectors_size() const;
  private:
  int _internal_vectors_size() const;

  public:
  void clear_vectors() ;
  ::vectordb::VectorWriteRequest* mutable_vectors(int index);
  ::google::protobuf::RepeatedPtrField< ::vectordb::VectorWriteRequest >*
      mutable_vectors();
  private:
  const ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>& _internal_vectors() const;
  ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>* _internal_mutable_vectors();
  public:
  const ::vectordb::VectorWriteRequest& vectors(int index) const;
  ::vectordb::VectorWriteRequest* add_vectors();
  const ::google::protobuf::RepeatedPtrField< ::vectordb::VectorWriteRequest >&
      vectors() const;
  // @@protoc_insertion_point(class_scope:vectordb.VectorBatchWriteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::vectordb::VectorWriteRequest > vectors_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// VectorWriteRequest

// string key = 1;
inline void VectorWriteRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorWriteRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorWriteRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorWriteRequest.key)
}
inline std::string* VectorWriteRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorWriteRequest.key)
  return _s;
}
inline const std::string& VectorWriteRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorWriteRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorWriteRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorWriteRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorWriteRequest.key)
  return _impl_.key_.Release();
}
inline void VectorWriteRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorWriteRequest.key)
}

// repeated float vector = 2;
inline int VectorWriteRequest::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int VectorWriteRequest::vector_size() const {
  return _internal_vector_size();
}
inline void VectorWriteRequest::clear_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_.Clear();
}
inline float VectorWriteRequest::vector(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteRequest.vector)
  return _internal_vector().Get(index);
}
inline void VectorWriteRequest::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorWriteRequest.vector)
}
inline void VectorWriteRequest::add_vector(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vector()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorWriteRequest.vector)
}
inline const ::google::protobuf::RepeatedField<float>& VectorWriteRequest::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorWriteRequest.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* VectorWriteRequest::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorWriteRequest.vector)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>& VectorWriteRequest::_internal_vector()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* VectorWriteRequest::_internal_mutable_vector() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vector_;
}

// -------------------------------------------------------------------

// VectorBatchWriteRequest

// repeated .vectordb.VectorWriteRequest vectors = 1;
inline int VectorBatchWriteRequest::_internal_vectors_size() const {
  return _internal_vectors().size();
}
inline int VectorBatchWriteRequest::vectors_size() const {
  return _internal_vectors_size();
}
inline void VectorBatchWriteRequest::clear_vectors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vectors_.Clear();
}
inline ::vectordb::VectorWriteRequest* VectorBatchWriteRequest::mutable_vectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:vectordb.VectorBatchWriteRequest.vectors)
  return _internal_mutable_vectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>* VectorBatchWriteRequest::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorBatchWriteRequest.vectors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vectors();
}
inline const ::vectordb::VectorWriteRequest& VectorBatchWriteRequest::vectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorBatchWriteRequest.vectors)
  return _internal_vectors().Get(index);
}
inline ::vectordb::VectorWriteRequest* VectorBatchWriteRequest::add_vectors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::vectordb::VectorWriteRequest* _add = _internal_mutable_vectors()->Add();
  // @@protoc_insertion_point(field_add:vectordb.VectorBatchWriteRequest.vectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>& VectorBatchWriteRequest::vectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorBatchWriteRequest.vectors)
  return _internal_vectors();
}
inline const ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>&
VectorBatchWriteRequest::_internal_vectors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vectors_;
}
inline ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>*
VectorBatchWriteRequest::_internal_mutable_vectors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vectors_;
}

// -------------------------------------------------------------------

// VectorWriteResponse

// bool success = 1;
inline void VectorWriteResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool VectorWriteResponse::success() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteResponse.success)
  return _internal_success();
}
inline void VectorWriteResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorWriteResponse.success)
}
inline bool VectorWriteResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void VectorWriteResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// VectorReadRequest

// string key = 1;
inline void VectorReadRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorReadRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorReadRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorReadRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorReadRequest.key)
}
inline std::string* VectorReadRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorReadRequest.key)
  return _s;
}
inline const std::string& VectorReadRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorReadRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorReadRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorReadRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorReadRequest.key)
  return _impl_.key_.Release();
}
inline void VectorReadRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorReadRequest.key)
}

// -------------------------------------------------------------------

// VectorReadResponse

// repeated float vector = 1;
inline int VectorReadResponse::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int VectorReadResponse::vector_size() const {
  return _internal_vector_size();
}
inline void VectorReadResponse::clear_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_.Clear();
}
inline float VectorReadResponse::vector(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorReadResponse.vector)
  return _internal_vector().Get(index);
}
inline void VectorReadResponse::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorReadResponse.vector)
}
inline void VectorReadResponse::add_vector(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vector()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorReadResponse.vector)
}
inline const ::google::protobuf::RepeatedField<float>& VectorReadResponse::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorReadResponse.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* VectorReadResponse::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorReadResponse.vector)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>& VectorReadResponse::_internal_vector()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* VectorReadResponse::_internal_mutable_vector() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vector_;
}

// bool found = 2;
inline void VectorReadResponse::clear_found() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.found_ = false;
}
inline bool VectorReadResponse::found() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorReadResponse.found)
  return _internal_found();
}
inline void VectorReadResponse::set_found(bool value) {
  _internal_set_found(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorReadResponse.found)
}
inline bool VectorReadResponse::_internal_found() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.found_;
}
inline void VectorReadResponse::_internal_set_found(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.found_ = value;
}

// -------------------------------------------------------------------

// VectorUpdateRequest

// string key = 1;
inline void VectorUpdateRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorUpdateRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorUpdateRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorUpdateRequest.key)
}
inline std::string* VectorUpdateRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorUpdateRequest.key)
  return _s;
}
inline const std::string& VectorUpdateRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorUpdateRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorUpdateRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorUpdateRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorUpdateRequest.key)
  return _impl_.key_.Release();
}
inline void VectorUpdateRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorUpdateRequest.key)
}

// repeated float vector = 2;
inline int VectorUpdateRequest::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int VectorUpdateRequest::vector_size() const {
  return _internal_vector_size();
}
inline void VectorUpdateRequest::clear_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_.Clear();
}
inline float VectorUpdateRequest::vector(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateRequest.vector)
  return _internal_vector().Get(index);
}
inline void VectorUpdateRequest::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorUpdateRequest.vector)
}
inline void VectorUpdateRequest::add_vector(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vector()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorUpdateRequest.vector)
}
inline const ::google::protobuf::RepeatedField<float>& VectorUpdateRequest::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorUpdateRequest.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* VectorUpdateRequest::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorUpdateRequest.vector)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>& VectorUpdateRequest::_internal_vector()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* VectorUpdateRequest::_internal_mutable_vector() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vector_;
}

// -------------------------------------------------------------------

// VectorUpdateResponse

// bool success = 1;
inline void VectorUpdateResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool VectorUpdateResponse::success() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateResponse.success)
  return _internal_success();
}
inline void VectorUpdateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorUpdateResponse.success)
}
inline bool VectorUpdateResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void VectorUpdateResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// VectorDeleteRequest

// string key = 1;
inline void VectorDeleteRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorDeleteRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorDeleteRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorDeleteRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorDeleteRequest.key)
}
inline std::string* VectorDeleteRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorDeleteRequest.key)
  return _s;
}
inline const std::string& VectorDeleteRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorDeleteRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorDeleteRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorDeleteRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorDeleteRequest.key)
  return _impl_.key_.Release();
}
inline void VectorDeleteRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorDeleteRequest.key)
}

// -------------------------------------------------------------------

// VectorDeleteResponse

// bool success = 1;
inline void VectorDeleteResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool VectorDeleteResponse::success() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorDeleteResponse.success)
  return _internal_success();
}
inline void VectorDeleteResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorDeleteResponse.success)
}
inline bool VectorDeleteResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void VectorDeleteResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// VectorEmbedAndWriteRequest

// string key = 1;
inline void VectorEmbedAndWriteRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorEmbedAndWriteRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorEmbedAndWriteRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorEmbedAndWriteRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorEmbedAndWriteRequest.key)
}
inline std::string* VectorEmbedAndWriteRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorEmbedAndWriteRequest.key)
  return _s;
}
inline const std::string& VectorEmbedAndWriteRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorEmbedAndWriteRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorEmbedAndWriteRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorEmbedAndWriteRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorEmbedAndWriteRequest.key)
  return _impl_.key_.Release();
}
inline void VectorEmbedAndWriteRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorEmbedAndWriteRequest.key)
}

// repeated float data = 2;
inline int VectorEmbedAndWriteRequest::_internal_data_size() const {
  return _internal_data().size();
}
inline int VectorEmbedAndWriteRequest::data_size() const {
  return _internal_data_size();
}
inline void VectorEmbedAndWriteRequest::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline float VectorEmbedAndWriteRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorEmbedAndWriteRequest.data)
  return _internal_data().Get(index);
}
inline void VectorEmbedAndWriteRequest::set_data(int index, float value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorEmbedAndWriteRequest.data)
}
inline void VectorEmbedAndWriteRequest::add_data(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorEmbedAndWriteRequest.data)
}
inline const ::google::protobuf::RepeatedField<float>& VectorEmbedAndWriteRequest::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorEmbedAndWriteRequest.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<float>* VectorEmbedAndWriteRequest::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorEmbedAndWriteRequest.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<float>& VectorEmbedAndWriteRequest::_internal_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<float>* VectorEmbedAndWriteRequest::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// int32 rows = 3;
inline void VectorEmbedAndWriteRequest::clear_rows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rows_ = 0;
}
inline ::int32_t VectorEmbedAndWriteRequest::rows() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorEmbedAndWriteRequest.rows)
  return _internal_rows();
}
inline void VectorEmbedAndWriteRequest::set_rows(::int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorEmbedAndWriteRequest.rows)
}
inline ::int32_t VectorEmbedAndWriteRequest::_internal_rows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rows_;
}
inline void VectorEmbedAndWriteRequest::_internal_set_rows(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rows_ = value;
}

// int32 cols = 4;
inline void VectorEmbedAndWriteRequest::clear_cols() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cols_ = 0;
}
inline ::int32_t VectorEmbedAndWriteRequest::cols() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorEmbedAndWriteRequest.cols)
  return _internal_cols();
}
inline void VectorEmbedAndWriteRequest::set_cols(::int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorEmbedAndWriteRequest.cols)
}
inline ::int32_t VectorEmbedAndWriteRequest::_internal_cols() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cols_;
}
inline void VectorEmbedAndWriteRequest::_internal_set_cols(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cols_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace vectordb


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_rust_5fserver_2fproto_2fvectordb_2eproto_2epb_2eh
