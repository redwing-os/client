// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rust_server/proto/vectordb.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_rust_5fserver_2fproto_2fvectordb_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_rust_5fserver_2fproto_2fvectordb_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_rust_5fserver_2fproto_2fvectordb_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_rust_5fserver_2fproto_2fvectordb_2eproto;
namespace vectordb {
class SearchResult;
struct SearchResultDefaultTypeInternal;
extern SearchResultDefaultTypeInternal _SearchResult_default_instance_;
class VectorBatchWriteRequest;
struct VectorBatchWriteRequestDefaultTypeInternal;
extern VectorBatchWriteRequestDefaultTypeInternal _VectorBatchWriteRequest_default_instance_;
class VectorDeleteRequest;
struct VectorDeleteRequestDefaultTypeInternal;
extern VectorDeleteRequestDefaultTypeInternal _VectorDeleteRequest_default_instance_;
class VectorDeleteResponse;
struct VectorDeleteResponseDefaultTypeInternal;
extern VectorDeleteResponseDefaultTypeInternal _VectorDeleteResponse_default_instance_;
class VectorReadRequest;
struct VectorReadRequestDefaultTypeInternal;
extern VectorReadRequestDefaultTypeInternal _VectorReadRequest_default_instance_;
class VectorReadResponse;
struct VectorReadResponseDefaultTypeInternal;
extern VectorReadResponseDefaultTypeInternal _VectorReadResponse_default_instance_;
class VectorSearchRequest;
struct VectorSearchRequestDefaultTypeInternal;
extern VectorSearchRequestDefaultTypeInternal _VectorSearchRequest_default_instance_;
class VectorSearchResponse;
struct VectorSearchResponseDefaultTypeInternal;
extern VectorSearchResponseDefaultTypeInternal _VectorSearchResponse_default_instance_;
class VectorUpdateRequest;
struct VectorUpdateRequestDefaultTypeInternal;
extern VectorUpdateRequestDefaultTypeInternal _VectorUpdateRequest_default_instance_;
class VectorUpdateResponse;
struct VectorUpdateResponseDefaultTypeInternal;
extern VectorUpdateResponseDefaultTypeInternal _VectorUpdateResponse_default_instance_;
class VectorWriteRequest;
struct VectorWriteRequestDefaultTypeInternal;
extern VectorWriteRequestDefaultTypeInternal _VectorWriteRequest_default_instance_;
class VectorWriteResponse;
struct VectorWriteResponseDefaultTypeInternal;
extern VectorWriteResponseDefaultTypeInternal _VectorWriteResponse_default_instance_;
}  // namespace vectordb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace vectordb {

// ===================================================================


// -------------------------------------------------------------------

class VectorWriteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorWriteResponse) */ {
 public:
  inline VectorWriteResponse() : VectorWriteResponse(nullptr) {}
  ~VectorWriteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorWriteResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorWriteResponse(const VectorWriteResponse& from)
      : VectorWriteResponse(nullptr, from) {}
  VectorWriteResponse(VectorWriteResponse&& from) noexcept
    : VectorWriteResponse() {
    *this = ::std::move(from);
  }

  inline VectorWriteResponse& operator=(const VectorWriteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorWriteResponse& operator=(VectorWriteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorWriteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorWriteResponse* internal_default_instance() {
    return reinterpret_cast<const VectorWriteResponse*>(
               &_VectorWriteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VectorWriteResponse& a, VectorWriteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorWriteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorWriteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorWriteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorWriteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorWriteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorWriteResponse& from) {
    VectorWriteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorWriteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorWriteResponse";
  }
  protected:
  explicit VectorWriteResponse(::google::protobuf::Arena* arena);
  VectorWriteResponse(::google::protobuf::Arena* arena, const VectorWriteResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorWriteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorUpdateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorUpdateResponse) */ {
 public:
  inline VectorUpdateResponse() : VectorUpdateResponse(nullptr) {}
  ~VectorUpdateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorUpdateResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorUpdateResponse(const VectorUpdateResponse& from)
      : VectorUpdateResponse(nullptr, from) {}
  VectorUpdateResponse(VectorUpdateResponse&& from) noexcept
    : VectorUpdateResponse() {
    *this = ::std::move(from);
  }

  inline VectorUpdateResponse& operator=(const VectorUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorUpdateResponse& operator=(VectorUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const VectorUpdateResponse*>(
               &_VectorUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VectorUpdateResponse& a, VectorUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorUpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorUpdateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorUpdateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorUpdateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorUpdateResponse& from) {
    VectorUpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorUpdateResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorUpdateResponse";
  }
  protected:
  explicit VectorUpdateResponse(::google::protobuf::Arena* arena);
  VectorUpdateResponse(::google::protobuf::Arena* arena, const VectorUpdateResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorUpdateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorSearchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorSearchRequest) */ {
 public:
  inline VectorSearchRequest() : VectorSearchRequest(nullptr) {}
  ~VectorSearchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorSearchRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorSearchRequest(const VectorSearchRequest& from)
      : VectorSearchRequest(nullptr, from) {}
  VectorSearchRequest(VectorSearchRequest&& from) noexcept
    : VectorSearchRequest() {
    *this = ::std::move(from);
  }

  inline VectorSearchRequest& operator=(const VectorSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchRequest& operator=(VectorSearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchRequest* internal_default_instance() {
    return reinterpret_cast<const VectorSearchRequest*>(
               &_VectorSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VectorSearchRequest& a, VectorSearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorSearchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorSearchRequest& from) {
    VectorSearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorSearchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorSearchRequest";
  }
  protected:
  explicit VectorSearchRequest(::google::protobuf::Arena* arena);
  VectorSearchRequest(::google::protobuf::Arena* arena, const VectorSearchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kMetricFieldNumber = 3,
    kTopKFieldNumber = 2,
    kThresholdFieldNumber = 4,
  };
  // repeated float query = 1;
  int query_size() const;
  private:
  int _internal_query_size() const;

  public:
  void clear_query() ;
  float query(int index) const;
  void set_query(int index, float value);
  void add_query(float value);
  const ::google::protobuf::RepeatedField<float>& query() const;
  ::google::protobuf::RepeatedField<float>* mutable_query();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_query() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_query();

  public:
  // string metric = 3;
  void clear_metric() ;
  const std::string& metric() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metric(Arg_&& arg, Args_... args);
  std::string* mutable_metric();
  PROTOBUF_NODISCARD std::string* release_metric();
  void set_allocated_metric(std::string* value);

  private:
  const std::string& _internal_metric() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric(
      const std::string& value);
  std::string* _internal_mutable_metric();

  public:
  // int32 top_k = 2;
  void clear_top_k() ;
  ::int32_t top_k() const;
  void set_top_k(::int32_t value);

  private:
  ::int32_t _internal_top_k() const;
  void _internal_set_top_k(::int32_t value);

  public:
  // float threshold = 4;
  void clear_threshold() ;
  float threshold() const;
  void set_threshold(float value);

  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorSearchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> query_;
    ::google::protobuf::internal::ArenaStringPtr metric_;
    ::int32_t top_k_;
    float threshold_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorReadResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorReadResponse) */ {
 public:
  inline VectorReadResponse() : VectorReadResponse(nullptr) {}
  ~VectorReadResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorReadResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorReadResponse(const VectorReadResponse& from)
      : VectorReadResponse(nullptr, from) {}
  VectorReadResponse(VectorReadResponse&& from) noexcept
    : VectorReadResponse() {
    *this = ::std::move(from);
  }

  inline VectorReadResponse& operator=(const VectorReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorReadResponse& operator=(VectorReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorReadResponse* internal_default_instance() {
    return reinterpret_cast<const VectorReadResponse*>(
               &_VectorReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VectorReadResponse& a, VectorReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorReadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorReadResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorReadResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorReadResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorReadResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorReadResponse& from) {
    VectorReadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorReadResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorReadResponse";
  }
  protected:
  explicit VectorReadResponse(::google::protobuf::Arena* arena);
  VectorReadResponse(::google::protobuf::Arena* arena, const VectorReadResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 1,
    kFoundFieldNumber = 2,
  };
  // repeated float vector = 1;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vector();

  public:
  // bool found = 2;
  void clear_found() ;
  bool found() const;
  void set_found(bool value);

  private:
  bool _internal_found() const;
  void _internal_set_found(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorReadResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> vector_;
    bool found_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorReadRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorReadRequest) */ {
 public:
  inline VectorReadRequest() : VectorReadRequest(nullptr) {}
  ~VectorReadRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorReadRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorReadRequest(const VectorReadRequest& from)
      : VectorReadRequest(nullptr, from) {}
  VectorReadRequest(VectorReadRequest&& from) noexcept
    : VectorReadRequest() {
    *this = ::std::move(from);
  }

  inline VectorReadRequest& operator=(const VectorReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorReadRequest& operator=(VectorReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorReadRequest* internal_default_instance() {
    return reinterpret_cast<const VectorReadRequest*>(
               &_VectorReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VectorReadRequest& a, VectorReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorReadRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorReadRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorReadRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorReadRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorReadRequest& from) {
    VectorReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorReadRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorReadRequest";
  }
  protected:
  explicit VectorReadRequest(::google::protobuf::Arena* arena);
  VectorReadRequest(::google::protobuf::Arena* arena, const VectorReadRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorReadRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorDeleteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorDeleteResponse) */ {
 public:
  inline VectorDeleteResponse() : VectorDeleteResponse(nullptr) {}
  ~VectorDeleteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorDeleteResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorDeleteResponse(const VectorDeleteResponse& from)
      : VectorDeleteResponse(nullptr, from) {}
  VectorDeleteResponse(VectorDeleteResponse&& from) noexcept
    : VectorDeleteResponse() {
    *this = ::std::move(from);
  }

  inline VectorDeleteResponse& operator=(const VectorDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorDeleteResponse& operator=(VectorDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const VectorDeleteResponse*>(
               &_VectorDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VectorDeleteResponse& a, VectorDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorDeleteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorDeleteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorDeleteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorDeleteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorDeleteResponse& from) {
    VectorDeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorDeleteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorDeleteResponse";
  }
  protected:
  explicit VectorDeleteResponse(::google::protobuf::Arena* arena);
  VectorDeleteResponse(::google::protobuf::Arena* arena, const VectorDeleteResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorDeleteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorDeleteRequest) */ {
 public:
  inline VectorDeleteRequest() : VectorDeleteRequest(nullptr) {}
  ~VectorDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorDeleteRequest(const VectorDeleteRequest& from)
      : VectorDeleteRequest(nullptr, from) {}
  VectorDeleteRequest(VectorDeleteRequest&& from) noexcept
    : VectorDeleteRequest() {
    *this = ::std::move(from);
  }

  inline VectorDeleteRequest& operator=(const VectorDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorDeleteRequest& operator=(VectorDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorDeleteRequest*>(
               &_VectorDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VectorDeleteRequest& a, VectorDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorDeleteRequest& from) {
    VectorDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorDeleteRequest";
  }
  protected:
  explicit VectorDeleteRequest(::google::protobuf::Arena* arena);
  VectorDeleteRequest(::google::protobuf::Arena* arena, const VectorDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class SearchResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.SearchResult) */ {
 public:
  inline SearchResult() : SearchResult(nullptr) {}
  ~SearchResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SearchResult(::google::protobuf::internal::ConstantInitialized);

  inline SearchResult(const SearchResult& from)
      : SearchResult(nullptr, from) {}
  SearchResult(SearchResult&& from) noexcept
    : SearchResult() {
    *this = ::std::move(from);
  }

  inline SearchResult& operator=(const SearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResult& operator=(SearchResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResult* internal_default_instance() {
    return reinterpret_cast<const SearchResult*>(
               &_SearchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SearchResult& a, SearchResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SearchResult& from) {
    SearchResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SearchResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.SearchResult";
  }
  protected:
  explicit SearchResult(::google::protobuf::Arena* arena);
  SearchResult(::google::protobuf::Arena* arena, const SearchResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kScoreFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // float score = 2;
  void clear_score() ;
  float score() const;
  void set_score(float value);

  private:
  float _internal_score() const;
  void _internal_set_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:vectordb.SearchResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    float score_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorWriteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorWriteRequest) */ {
 public:
  inline VectorWriteRequest() : VectorWriteRequest(nullptr) {}
  ~VectorWriteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorWriteRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorWriteRequest(const VectorWriteRequest& from)
      : VectorWriteRequest(nullptr, from) {}
  VectorWriteRequest(VectorWriteRequest&& from) noexcept
    : VectorWriteRequest() {
    *this = ::std::move(from);
  }

  inline VectorWriteRequest& operator=(const VectorWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorWriteRequest& operator=(VectorWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorWriteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorWriteRequest*>(
               &_VectorWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VectorWriteRequest& a, VectorWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorWriteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorWriteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorWriteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorWriteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorWriteRequest& from) {
    VectorWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorWriteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorWriteRequest";
  }
  protected:
  explicit VectorWriteRequest(::google::protobuf::Arena* arena);
  VectorWriteRequest(::google::protobuf::Arena* arena, const VectorWriteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 2,
    kKeyFieldNumber = 1,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
  };
  // repeated float vector = 2;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vector();

  public:
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 4;
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorWriteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> vector_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorUpdateRequest) */ {
 public:
  inline VectorUpdateRequest() : VectorUpdateRequest(nullptr) {}
  ~VectorUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorUpdateRequest(const VectorUpdateRequest& from)
      : VectorUpdateRequest(nullptr, from) {}
  VectorUpdateRequest(VectorUpdateRequest&& from) noexcept
    : VectorUpdateRequest() {
    *this = ::std::move(from);
  }

  inline VectorUpdateRequest& operator=(const VectorUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorUpdateRequest& operator=(VectorUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const VectorUpdateRequest*>(
               &_VectorUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VectorUpdateRequest& a, VectorUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorUpdateRequest& from) {
    VectorUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorUpdateRequest";
  }
  protected:
  explicit VectorUpdateRequest(::google::protobuf::Arena* arena);
  VectorUpdateRequest(::google::protobuf::Arena* arena, const VectorUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 2,
    kKeyFieldNumber = 1,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
  };
  // repeated float vector = 2;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vector();

  public:
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 4;
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // @@protoc_insertion_point(class_scope:vectordb.VectorUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> vector_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorSearchResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorSearchResponse) */ {
 public:
  inline VectorSearchResponse() : VectorSearchResponse(nullptr) {}
  ~VectorSearchResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorSearchResponse(::google::protobuf::internal::ConstantInitialized);

  inline VectorSearchResponse(const VectorSearchResponse& from)
      : VectorSearchResponse(nullptr, from) {}
  VectorSearchResponse(VectorSearchResponse&& from) noexcept
    : VectorSearchResponse() {
    *this = ::std::move(from);
  }

  inline VectorSearchResponse& operator=(const VectorSearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchResponse& operator=(VectorSearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchResponse* internal_default_instance() {
    return reinterpret_cast<const VectorSearchResponse*>(
               &_VectorSearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VectorSearchResponse& a, VectorSearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorSearchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorSearchResponse& from) {
    VectorSearchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorSearchResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorSearchResponse";
  }
  protected:
  explicit VectorSearchResponse(::google::protobuf::Arena* arena);
  VectorSearchResponse(::google::protobuf::Arena* arena, const VectorSearchResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchesFieldNumber = 1,
  };
  // repeated .vectordb.SearchResult matches = 1;
  int matches_size() const;
  private:
  int _internal_matches_size() const;

  public:
  void clear_matches() ;
  ::vectordb::SearchResult* mutable_matches(int index);
  ::google::protobuf::RepeatedPtrField< ::vectordb::SearchResult >*
      mutable_matches();
  private:
  const ::google::protobuf::RepeatedPtrField<::vectordb::SearchResult>& _internal_matches() const;
  ::google::protobuf::RepeatedPtrField<::vectordb::SearchResult>* _internal_mutable_matches();
  public:
  const ::vectordb::SearchResult& matches(int index) const;
  ::vectordb::SearchResult* add_matches();
  const ::google::protobuf::RepeatedPtrField< ::vectordb::SearchResult >&
      matches() const;
  // @@protoc_insertion_point(class_scope:vectordb.VectorSearchResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::vectordb::SearchResult > matches_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};// -------------------------------------------------------------------

class VectorBatchWriteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vectordb.VectorBatchWriteRequest) */ {
 public:
  inline VectorBatchWriteRequest() : VectorBatchWriteRequest(nullptr) {}
  ~VectorBatchWriteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorBatchWriteRequest(::google::protobuf::internal::ConstantInitialized);

  inline VectorBatchWriteRequest(const VectorBatchWriteRequest& from)
      : VectorBatchWriteRequest(nullptr, from) {}
  VectorBatchWriteRequest(VectorBatchWriteRequest&& from) noexcept
    : VectorBatchWriteRequest() {
    *this = ::std::move(from);
  }

  inline VectorBatchWriteRequest& operator=(const VectorBatchWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorBatchWriteRequest& operator=(VectorBatchWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorBatchWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorBatchWriteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorBatchWriteRequest*>(
               &_VectorBatchWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VectorBatchWriteRequest& a, VectorBatchWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorBatchWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorBatchWriteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorBatchWriteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorBatchWriteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorBatchWriteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorBatchWriteRequest& from) {
    VectorBatchWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorBatchWriteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vectordb.VectorBatchWriteRequest";
  }
  protected:
  explicit VectorBatchWriteRequest(::google::protobuf::Arena* arena);
  VectorBatchWriteRequest(::google::protobuf::Arena* arena, const VectorBatchWriteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorsFieldNumber = 1,
  };
  // repeated .vectordb.VectorWriteRequest vectors = 1;
  int vectors_size() const;
  private:
  int _internal_vectors_size() const;

  public:
  void clear_vectors() ;
  ::vectordb::VectorWriteRequest* mutable_vectors(int index);
  ::google::protobuf::RepeatedPtrField< ::vectordb::VectorWriteRequest >*
      mutable_vectors();
  private:
  const ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>& _internal_vectors() const;
  ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>* _internal_mutable_vectors();
  public:
  const ::vectordb::VectorWriteRequest& vectors(int index) const;
  ::vectordb::VectorWriteRequest* add_vectors();
  const ::google::protobuf::RepeatedPtrField< ::vectordb::VectorWriteRequest >&
      vectors() const;
  // @@protoc_insertion_point(class_scope:vectordb.VectorBatchWriteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::vectordb::VectorWriteRequest > vectors_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rust_5fserver_2fproto_2fvectordb_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// VectorWriteRequest

// string key = 1;
inline void VectorWriteRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorWriteRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorWriteRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorWriteRequest.key)
}
inline std::string* VectorWriteRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorWriteRequest.key)
  return _s;
}
inline const std::string& VectorWriteRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorWriteRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorWriteRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorWriteRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorWriteRequest.key)
  return _impl_.key_.Release();
}
inline void VectorWriteRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorWriteRequest.key)
}

// repeated float vector = 2;
inline int VectorWriteRequest::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int VectorWriteRequest::vector_size() const {
  return _internal_vector_size();
}
inline void VectorWriteRequest::clear_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_.Clear();
}
inline float VectorWriteRequest::vector(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteRequest.vector)
  return _internal_vector().Get(index);
}
inline void VectorWriteRequest::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorWriteRequest.vector)
}
inline void VectorWriteRequest::add_vector(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vector()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorWriteRequest.vector)
}
inline const ::google::protobuf::RepeatedField<float>& VectorWriteRequest::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorWriteRequest.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* VectorWriteRequest::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorWriteRequest.vector)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>& VectorWriteRequest::_internal_vector()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* VectorWriteRequest::_internal_mutable_vector() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vector_;
}

// .google.protobuf.Timestamp created_at = 3;
inline bool VectorWriteRequest::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& VectorWriteRequest::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& VectorWriteRequest::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteRequest.created_at)
  return _internal_created_at();
}
inline void VectorWriteRequest::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vectordb.VectorWriteRequest.created_at)
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorWriteRequest.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorWriteRequest.created_at)
  return _msg;
}
inline void VectorWriteRequest::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorWriteRequest.created_at)
}

// .google.protobuf.Timestamp updated_at = 4;
inline bool VectorWriteRequest::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& VectorWriteRequest::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& VectorWriteRequest::updated_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteRequest.updated_at)
  return _internal_updated_at();
}
inline void VectorWriteRequest::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vectordb.VectorWriteRequest.updated_at)
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorWriteRequest.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* VectorWriteRequest::mutable_updated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorWriteRequest.updated_at)
  return _msg;
}
inline void VectorWriteRequest::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorWriteRequest.updated_at)
}

// -------------------------------------------------------------------

// VectorBatchWriteRequest

// repeated .vectordb.VectorWriteRequest vectors = 1;
inline int VectorBatchWriteRequest::_internal_vectors_size() const {
  return _internal_vectors().size();
}
inline int VectorBatchWriteRequest::vectors_size() const {
  return _internal_vectors_size();
}
inline void VectorBatchWriteRequest::clear_vectors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vectors_.Clear();
}
inline ::vectordb::VectorWriteRequest* VectorBatchWriteRequest::mutable_vectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:vectordb.VectorBatchWriteRequest.vectors)
  return _internal_mutable_vectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>* VectorBatchWriteRequest::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorBatchWriteRequest.vectors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vectors();
}
inline const ::vectordb::VectorWriteRequest& VectorBatchWriteRequest::vectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorBatchWriteRequest.vectors)
  return _internal_vectors().Get(index);
}
inline ::vectordb::VectorWriteRequest* VectorBatchWriteRequest::add_vectors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::vectordb::VectorWriteRequest* _add = _internal_mutable_vectors()->Add();
  // @@protoc_insertion_point(field_add:vectordb.VectorBatchWriteRequest.vectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>& VectorBatchWriteRequest::vectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorBatchWriteRequest.vectors)
  return _internal_vectors();
}
inline const ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>&
VectorBatchWriteRequest::_internal_vectors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vectors_;
}
inline ::google::protobuf::RepeatedPtrField<::vectordb::VectorWriteRequest>*
VectorBatchWriteRequest::_internal_mutable_vectors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vectors_;
}

// -------------------------------------------------------------------

// VectorWriteResponse

// bool success = 1;
inline void VectorWriteResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool VectorWriteResponse::success() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorWriteResponse.success)
  return _internal_success();
}
inline void VectorWriteResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorWriteResponse.success)
}
inline bool VectorWriteResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void VectorWriteResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// VectorReadRequest

// string key = 1;
inline void VectorReadRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorReadRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorReadRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorReadRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorReadRequest.key)
}
inline std::string* VectorReadRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorReadRequest.key)
  return _s;
}
inline const std::string& VectorReadRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorReadRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorReadRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorReadRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorReadRequest.key)
  return _impl_.key_.Release();
}
inline void VectorReadRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorReadRequest.key)
}

// -------------------------------------------------------------------

// VectorReadResponse

// repeated float vector = 1;
inline int VectorReadResponse::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int VectorReadResponse::vector_size() const {
  return _internal_vector_size();
}
inline void VectorReadResponse::clear_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_.Clear();
}
inline float VectorReadResponse::vector(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorReadResponse.vector)
  return _internal_vector().Get(index);
}
inline void VectorReadResponse::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorReadResponse.vector)
}
inline void VectorReadResponse::add_vector(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vector()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorReadResponse.vector)
}
inline const ::google::protobuf::RepeatedField<float>& VectorReadResponse::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorReadResponse.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* VectorReadResponse::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorReadResponse.vector)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>& VectorReadResponse::_internal_vector()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* VectorReadResponse::_internal_mutable_vector() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vector_;
}

// bool found = 2;
inline void VectorReadResponse::clear_found() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.found_ = false;
}
inline bool VectorReadResponse::found() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorReadResponse.found)
  return _internal_found();
}
inline void VectorReadResponse::set_found(bool value) {
  _internal_set_found(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorReadResponse.found)
}
inline bool VectorReadResponse::_internal_found() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.found_;
}
inline void VectorReadResponse::_internal_set_found(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.found_ = value;
}

// -------------------------------------------------------------------

// VectorUpdateRequest

// string key = 1;
inline void VectorUpdateRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorUpdateRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorUpdateRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorUpdateRequest.key)
}
inline std::string* VectorUpdateRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorUpdateRequest.key)
  return _s;
}
inline const std::string& VectorUpdateRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorUpdateRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorUpdateRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorUpdateRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorUpdateRequest.key)
  return _impl_.key_.Release();
}
inline void VectorUpdateRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorUpdateRequest.key)
}

// repeated float vector = 2;
inline int VectorUpdateRequest::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int VectorUpdateRequest::vector_size() const {
  return _internal_vector_size();
}
inline void VectorUpdateRequest::clear_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_.Clear();
}
inline float VectorUpdateRequest::vector(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateRequest.vector)
  return _internal_vector().Get(index);
}
inline void VectorUpdateRequest::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorUpdateRequest.vector)
}
inline void VectorUpdateRequest::add_vector(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vector()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorUpdateRequest.vector)
}
inline const ::google::protobuf::RepeatedField<float>& VectorUpdateRequest::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorUpdateRequest.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* VectorUpdateRequest::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorUpdateRequest.vector)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>& VectorUpdateRequest::_internal_vector()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* VectorUpdateRequest::_internal_mutable_vector() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vector_;
}

// .google.protobuf.Timestamp created_at = 3;
inline bool VectorUpdateRequest::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& VectorUpdateRequest::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& VectorUpdateRequest::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateRequest.created_at)
  return _internal_created_at();
}
inline void VectorUpdateRequest::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vectordb.VectorUpdateRequest.created_at)
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorUpdateRequest.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorUpdateRequest.created_at)
  return _msg;
}
inline void VectorUpdateRequest::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorUpdateRequest.created_at)
}

// .google.protobuf.Timestamp updated_at = 4;
inline bool VectorUpdateRequest::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& VectorUpdateRequest::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& VectorUpdateRequest::updated_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateRequest.updated_at)
  return _internal_updated_at();
}
inline void VectorUpdateRequest::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vectordb.VectorUpdateRequest.updated_at)
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorUpdateRequest.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* VectorUpdateRequest::mutable_updated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorUpdateRequest.updated_at)
  return _msg;
}
inline void VectorUpdateRequest::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorUpdateRequest.updated_at)
}

// -------------------------------------------------------------------

// VectorUpdateResponse

// bool success = 1;
inline void VectorUpdateResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool VectorUpdateResponse::success() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorUpdateResponse.success)
  return _internal_success();
}
inline void VectorUpdateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorUpdateResponse.success)
}
inline bool VectorUpdateResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void VectorUpdateResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// VectorDeleteRequest

// string key = 1;
inline void VectorDeleteRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& VectorDeleteRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorDeleteRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorDeleteRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorDeleteRequest.key)
}
inline std::string* VectorDeleteRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorDeleteRequest.key)
  return _s;
}
inline const std::string& VectorDeleteRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void VectorDeleteRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* VectorDeleteRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* VectorDeleteRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorDeleteRequest.key)
  return _impl_.key_.Release();
}
inline void VectorDeleteRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorDeleteRequest.key)
}

// -------------------------------------------------------------------

// VectorDeleteResponse

// bool success = 1;
inline void VectorDeleteResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool VectorDeleteResponse::success() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorDeleteResponse.success)
  return _internal_success();
}
inline void VectorDeleteResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorDeleteResponse.success)
}
inline bool VectorDeleteResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void VectorDeleteResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// VectorSearchRequest

// repeated float query = 1;
inline int VectorSearchRequest::_internal_query_size() const {
  return _internal_query().size();
}
inline int VectorSearchRequest::query_size() const {
  return _internal_query_size();
}
inline void VectorSearchRequest::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.Clear();
}
inline float VectorSearchRequest::query(int index) const {
  // @@protoc_insertion_point(field_get:vectordb.VectorSearchRequest.query)
  return _internal_query().Get(index);
}
inline void VectorSearchRequest::set_query(int index, float value) {
  _internal_mutable_query()->Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb.VectorSearchRequest.query)
}
inline void VectorSearchRequest::add_query(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_query()->Add(value);
  // @@protoc_insertion_point(field_add:vectordb.VectorSearchRequest.query)
}
inline const ::google::protobuf::RepeatedField<float>& VectorSearchRequest::query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorSearchRequest.query)
  return _internal_query();
}
inline ::google::protobuf::RepeatedField<float>* VectorSearchRequest::mutable_query()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorSearchRequest.query)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_query();
}
inline const ::google::protobuf::RepeatedField<float>& VectorSearchRequest::_internal_query()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.query_;
}
inline ::google::protobuf::RepeatedField<float>* VectorSearchRequest::_internal_mutable_query() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.query_;
}

// int32 top_k = 2;
inline void VectorSearchRequest::clear_top_k() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_k_ = 0;
}
inline ::int32_t VectorSearchRequest::top_k() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorSearchRequest.top_k)
  return _internal_top_k();
}
inline void VectorSearchRequest::set_top_k(::int32_t value) {
  _internal_set_top_k(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorSearchRequest.top_k)
}
inline ::int32_t VectorSearchRequest::_internal_top_k() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_k_;
}
inline void VectorSearchRequest::_internal_set_top_k(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_k_ = value;
}

// string metric = 3;
inline void VectorSearchRequest::clear_metric() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_.ClearToEmpty();
}
inline const std::string& VectorSearchRequest::metric() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorSearchRequest.metric)
  return _internal_metric();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorSearchRequest::set_metric(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.VectorSearchRequest.metric)
}
inline std::string* VectorSearchRequest::mutable_metric() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metric();
  // @@protoc_insertion_point(field_mutable:vectordb.VectorSearchRequest.metric)
  return _s;
}
inline const std::string& VectorSearchRequest::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_.Get();
}
inline void VectorSearchRequest::_internal_set_metric(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_.Set(value, GetArena());
}
inline std::string* VectorSearchRequest::_internal_mutable_metric() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.metric_.Mutable( GetArena());
}
inline std::string* VectorSearchRequest::release_metric() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.VectorSearchRequest.metric)
  return _impl_.metric_.Release();
}
inline void VectorSearchRequest::set_allocated_metric(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metric_.IsDefault()) {
          _impl_.metric_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.VectorSearchRequest.metric)
}

// float threshold = 4;
inline void VectorSearchRequest::clear_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.threshold_ = 0;
}
inline float VectorSearchRequest::threshold() const {
  // @@protoc_insertion_point(field_get:vectordb.VectorSearchRequest.threshold)
  return _internal_threshold();
}
inline void VectorSearchRequest::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:vectordb.VectorSearchRequest.threshold)
}
inline float VectorSearchRequest::_internal_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.threshold_;
}
inline void VectorSearchRequest::_internal_set_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.threshold_ = value;
}

// -------------------------------------------------------------------

// VectorSearchResponse

// repeated .vectordb.SearchResult matches = 1;
inline int VectorSearchResponse::_internal_matches_size() const {
  return _internal_matches().size();
}
inline int VectorSearchResponse::matches_size() const {
  return _internal_matches_size();
}
inline void VectorSearchResponse::clear_matches() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matches_.Clear();
}
inline ::vectordb::SearchResult* VectorSearchResponse::mutable_matches(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:vectordb.VectorSearchResponse.matches)
  return _internal_mutable_matches()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::vectordb::SearchResult>* VectorSearchResponse::mutable_matches()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vectordb.VectorSearchResponse.matches)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_matches();
}
inline const ::vectordb::SearchResult& VectorSearchResponse::matches(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.VectorSearchResponse.matches)
  return _internal_matches().Get(index);
}
inline ::vectordb::SearchResult* VectorSearchResponse::add_matches() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::vectordb::SearchResult* _add = _internal_mutable_matches()->Add();
  // @@protoc_insertion_point(field_add:vectordb.VectorSearchResponse.matches)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::vectordb::SearchResult>& VectorSearchResponse::matches() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vectordb.VectorSearchResponse.matches)
  return _internal_matches();
}
inline const ::google::protobuf::RepeatedPtrField<::vectordb::SearchResult>&
VectorSearchResponse::_internal_matches() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.matches_;
}
inline ::google::protobuf::RepeatedPtrField<::vectordb::SearchResult>*
VectorSearchResponse::_internal_mutable_matches() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.matches_;
}

// -------------------------------------------------------------------

// SearchResult

// string key = 1;
inline void SearchResult::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SearchResult::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vectordb.SearchResult.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchResult::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vectordb.SearchResult.key)
}
inline std::string* SearchResult::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vectordb.SearchResult.key)
  return _s;
}
inline const std::string& SearchResult::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void SearchResult::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* SearchResult::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* SearchResult::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:vectordb.SearchResult.key)
  return _impl_.key_.Release();
}
inline void SearchResult::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vectordb.SearchResult.key)
}

// float score = 2;
inline void SearchResult::clear_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.score_ = 0;
}
inline float SearchResult::score() const {
  // @@protoc_insertion_point(field_get:vectordb.SearchResult.score)
  return _internal_score();
}
inline void SearchResult::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:vectordb.SearchResult.score)
}
inline float SearchResult::_internal_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_;
}
inline void SearchResult::_internal_set_score(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.score_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace vectordb


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_rust_5fserver_2fproto_2fvectordb_2eproto_2epb_2eh
